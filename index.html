<!DOCTYPE html>
<!--
* grrd's Dice
* Copyright (c) 2015 Gerard Tyedmers, grrd@gmx.net
* Licensed under the MPL License
-->
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<title>grrd's Dice</title>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="js/build/three.min.js"></script>
		<script src="js/loaders/STLLoader.js"></script>

		<script>

			var camera, scene, renderer;
			var mesh;

			var targetRotationX = 0;
			var targetRotationXOnMouseDown = 0;

			var targetRotationY = 0;
			var targetRotationYOnMouseDown = 0;

			var mouseX = 0;
			var mouseXOnMouseDown = 0;

			var mouseY = 0;
			var mouseYOnMouseDown = 0;


			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			init();
			animate();

			function init() {

				//renderer = new THREE.WebGLRenderer();

				renderer = new THREE.WebGLRenderer( { antialias: true } );

				renderer.gammaInput = true;
				renderer.gammaOutput = true;


				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 400;

				scene = new THREE.Scene();

				var geometry = new THREE.BoxGeometry( 200, 200, 200);

				var texture = THREE.ImageUtils.loadTexture( 'textures/crate.gif' );
				texture.anisotropy = renderer.getMaxAnisotropy();

				for ( var i = 0; i < geometry.faces.length; i += 2 ) {

					var hex = Math.random() * 0xffffff;
					geometry.faces[ i ].color.setHex( hex );
					geometry.faces[ i + 1 ].color.setHex( hex );

				}

				//var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );
				//var material = new THREE.MeshLambertMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );
				//var material = new THREE.MeshBasicMaterial( { map: texture } );
				var material = new THREE.MeshLambertMaterial( { map: texture } );

				var materials = [
				   new THREE.MeshLambertMaterial({
					   map: THREE.ImageUtils.loadTexture('textures/dice1.png')
				   }),
				   new THREE.MeshLambertMaterial({
					   map: THREE.ImageUtils.loadTexture('textures/dice6.png')
				   }),
				   new THREE.MeshLambertMaterial({
					   map: THREE.ImageUtils.loadTexture('textures/dice3.png')
				   }),
				   new THREE.MeshLambertMaterial({
					   map: THREE.ImageUtils.loadTexture('textures/dice4.png')
				   }),
				   new THREE.MeshLambertMaterial({
					   map: THREE.ImageUtils.loadTexture('textures/dice5.png')
				   }),
				   new THREE.MeshLambertMaterial({
					   map: THREE.ImageUtils.loadTexture('textures/dice2.png')
				   })
				];

				//mesh = new THREE.Mesh( geometry, material );
				mesh = new THREE.Mesh( geometry,  new THREE.MeshFaceMaterial( materials ) );

				/*
				loader = new THREE.JSONLoader();
				loader.load( "models/dice.json", function( geometry ) {
					mesh = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial() );
					mesh.scale.set( 10, 10, 10 );
					mesh.position.y = 150;
					mesh.position.x = 0;
				} );
				*/


				/*var loader = new THREE.STLLoader();
				loader.load( './models/dice.stl', function ( geometry ) {

					var material = new THREE.MeshPhongMaterial( { ambient: 0xFF0066, color: 0xFF0066, specular: 0x111111, shininess: 200 } );
					mesh = new THREE.Mesh( geometry, material );

					mesh.position.set( 0.3, 0, 0 );
					mesh.rotation.set( 0, - Math.PI / 2, 0 );
					mesh.scale.set( 0.01, 0.01, 0.01 );

					mesh.castShadow = true;
					mesh.receiveShadow = true;

					scene.add( mesh );

				} );*/

				scene.add( mesh );
				//loader.onLoadComplete=function(){scene.add( mesh )} 

				var light = new THREE.PointLight( 0xbbbbbb, 1, 0 );
				light.position.set( -50, 200, 700 );
				scene.add( light );

				var ambientLight = new THREE.AmbientLight(0x777777);
				scene.add(ambientLight);
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );
				window.addEventListener( 'resize', onWindowResize, false );

				addShadowedLight( 1, 1, 1, 0xffffff, 1.35 );
				addShadowedLight( 0.5, 1, -1, 0xffffff, 1 );


			}

			function addShadowedLight( x, y, z, color, intensity ) {

				var directionalLight = new THREE.DirectionalLight( color, intensity );
				directionalLight.position.set( x, y, z )
				scene.add( directionalLight );

				directionalLight.castShadow = true;
				// directionalLight.shadowCameraVisible = true;

				var d = 1;
				directionalLight.shadowCameraLeft = -d;
				directionalLight.shadowCameraRight = d;
				directionalLight.shadowCameraTop = d;
				directionalLight.shadowCameraBottom = -d;

				directionalLight.shadowCameraNear = 1;
				directionalLight.shadowCameraFar = 4;

				directionalLight.shadowMapWidth = 1024;
				directionalLight.shadowMapHeight = 1024;

				directionalLight.shadowBias = -0.005;
				directionalLight.shadowDarkness = 0.15;

			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				//mesh.rotation.x += 0.005;
				//mesh.rotation.y += 0.01;
				mesh.rotation.y += ( targetRotationX - mesh.rotation.y ) * 0.05;
				mesh.rotation.x += ( targetRotationY - mesh.rotation.x ) * 0.05;
				renderer.render( scene, camera );
			}

			function onDocumentMouseDown( event ) {
				event.preventDefault();
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mouseout', onDocumentMouseOut, false );
				mouseXOnMouseDown = event.clientX - windowHalfX;
				mouseYOnMouseDown = event.clientY - windowHalfY;
				targetRotationXOnMouseDown = targetRotationX;
				targetRotationYOnMouseDown = targetRotationY;
			}

			function onDocumentMouseMove( event ) {
				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;
				targetRotationX = targetRotationXOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;
				targetRotationY = targetRotationYOnMouseDown + ( mouseY - mouseYOnMouseDown ) * 0.02;
			}

			function onDocumentMouseUp( event ) {
				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function onDocumentMouseOut( event ) {
				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function onDocumentTouchStart( event ) {
				if ( event.touches.length === 1 ) {
					event.preventDefault();
					mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
					mouseYOnMouseDown = event.touches[ 0 ].pageY - windowHalfY;
					targetRotationXOnMouseDown = targetRotationX;
					targetRotationYOnMouseDown = targetRotationY;
				}
			}

			function onDocumentTouchMove( event ) {
				if ( event.touches.length === 1 ) {
					event.preventDefault();
					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					targetRotationX = targetRotationXOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.01;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;
					targetRotationY = targetRotationYOnMouseDown + ( mouseY - mouseYOnMouseDown ) * 0.01;
				}
			}

		</script>
		<canvas style="width: 291px; height: 625px;" height="625" width="291"></canvas>
	</body>
</html>
